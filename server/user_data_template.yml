#cloud-config

coreos:
  etcd2:
    discovery: {{.CoreosToken}}
    advertise-client-urls: http://$private_ipv4:2379,http://$private_ipv4:4001
    initial-advertise-peer-urls: http://$private_ipv4:2380
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    listen-peer-urls: http://$private_ipv4:2380
  fleet:
    public-ip: $private_ipv4
    metadata: region={{.BootstrapConfig.Region}},public_ip=$public_ipv4

  units:
    - name: etcd2.service
      command: start
    - name: fleet.service
      command: start

    - name: dolb_firewall.service
      command: start
      content: |
        [Unit]
        Description=Configure firewall for dolb agents
        After=fleet.socket
        Requires=fleet.socket

        [Service]
        TimeoutStartSec=0
        ExecStart=/root/bin/fixup_firewall.sh
    {{if .BootstrapConfig.HasSyslog}}- name: remote_syslog.service
      command: start
      content: |
        [Unit]
        Description=Remote Syslog
        After=systemd-journald.service
        Requires=systemd-journald.service

        [Service]
        ExecStart=/bin/sh -c "journalctl -f | ncat {{if .BootstrapConfig.RemoteSyslog.EnableSSL}}--ssl{{end}} {{.BootstrapConfig.RemoteSyslog.Host}} {{.BootstrapConfig.RemoteSyslog.Port}}"
        TimeoutStartSec=0
        Restart=on-failure
        RestartSec=5s
        
        [Install]
        WantedBy=multi-user.target{{end}}

    - name: dolb-agent-start.service
      command: start
      content: |
        [Unit]
        Description=Start dolb-agent
        After=docker.service etcd2.service dolb_firewall.service
        Requires=docker.service etcd2.service

        [Service]
        TimeoutStartSec=0
        ExecStart=/home/core/units/start-agent.sh

write_files:
  - path: /home/core/units/start-agent.sh
    permissions : 0755
    content: |
      #!/bin/bash -x

      denv=/home/core/digitalocean.env
      /usr/bin/grep -q -F 'DROPLET_ID' $denv || echo "DROPLET_ID=$(curl http://169.254.169.254/metadata/v1/id)" >> $denv

      source /etc/environment
      /usr/bin/etcdctl member list | /usr/bin/head -1 | /usr/bin/grep $COREOS_PRIVATE_IPV4 &> /dev/null
      rc=$?
      if [[ $rc == 0 ]]; then
        /usr/bin/fleetctl submit /home/core/units/dolb-agent@.service
        for i in 1 2 3; do
          /usr/bin/fleetctl start dolb-agent@$i.service
        done
      fi


  - path: /home/core/units/dolb-agent@.service
    permissions: 0644
    content: |
      [Unit]
      Description=dolb agent
      After=docker.service
      Requires=docker.service

      [Service]
      TimeoutStartSec=0
      Restart=always
      RestartSec=5s
      EnvironmentFile=/etc/environment
      Environment=AGENT_VERSION={{.AgentVersion}}
      ExecStartPre=/usr/bin/docker pull bryanl/dolb-agent:0.0.2
      ExecStart=/usr/bin/docker run -p 8889:8889 --rm --env-file /home/core/digitalocean.env  -e AGENT_NAME=dolb-agent-%i -e ETCDENDPOINTS=http://${COREOS_PRIVATE_IPV4}:4001 --name dolb-agent-%i bryanl/dolb-agent:0.0.2
      ExecStop=/usr/bin/docker kill dolb-agent-%i

      [X-Fleet]
      Conflicts=dolb-agent@*.service
  - path: /home/core/digitalocean.env
    permissions: 0644
    content: |
      DIGITALOCEAN_ACCESS_TOKEN={{.BootstrapConfig.DigitalOceanToken}}
      AGENT_REGION={{.BootstrapConfig.Region}}
  - path: /root/bin/fixup_firewall.sh
    permissions: 0755
    content: |
      #!/bin/bash -x

      timeout=10

      max_attempts=20
      attempt=0
      etcd_available=0
      while [[ $attempt < $max_attempts ]]; do
        # obtain the etcd node members and check that at least there is three
        ETCD_NODES=$(curl -s http://localhost:4001/v2/members | jq '.[] | .[].peerURLs | length' | wc -l)
        if test $ETCD_NODES -lt 3; then
          echo "etcd is not working correctly. Verify the etcd cluster is running before the execution of this script."
        else
          etcd_available=1
          break
        fi

        echo "Retrying in $timeout..." 1>&2
        sleep $timeout
        attempt=$(( attempt + 1 ))
        timeout=$(( timeout * 2 ))
      done

      if [[ $etcd_available != 1 ]]; then
        echo "Timed out waiting for etcd to be availble. Exiting..."
        exit 1
      fi

      attempt=0
      fleetctl_available=0
      while [[ $attempt < $max_attempts ]]; do
        fleetct=$(fleetctl list-machines | wc -l)
        if test $fleetct -lt 4; then
          echo "Waiting for fleet to become available"
        else
          fleetctl_available=1
          break
        fi
        echo "Retrying in $timeout..." 1>&2
        sleep $timeout
        attempt=$(( attempt + 1 ))
        timeout=$(( timeout * 2 ))
      done

      if [[ $fleetctl_available != 1 ]]; then
        echo "Timed out waiting for fleet to be availble. Exiting..."
        exit 1
      fi

      echo "Obtaining IP addresses of the nodes in the cluster..."
      MACHINES_IP=$(fleetctl list-machines --fields=ip --no-legend | awk -vORS=, '{ print $1 }' | sed 's/,$/\n/')

      if [ -n "$NEW_NODE" ]; then
        MACHINES_IP+=,$NEW_NODE
      fi

      echo "Cluster IPs: $MACHINES_IP"

      echo "Creating firewall Rules..."
      # Firewall Template
      template=$(cat <<EOF
      *filter

      :INPUT DROP [0:0]
      :FORWARD DROP [0:0]
      :OUTPUT ACCEPT [0:0]
      :Firewall-INPUT - [0:0]
      -A INPUT -j Firewall-INPUT
      -A FORWARD -j Firewall-INPUT
      -A Firewall-INPUT -i lo -j ACCEPT
      -A Firewall-INPUT -p icmp --icmp-type echo-reply -j ACCEPT
      -A Firewall-INPUT -p icmp --icmp-type destination-unreachable -j ACCEPT
      -A Firewall-INPUT -p icmp --icmp-type time-exceeded -j ACCEPT

      # Ping
      -A Firewall-INPUT -p icmp --icmp-type echo-request -j ACCEPT

      # Accept any established connections
      -A Firewall-INPUT -m conntrack --ctstate  ESTABLISHED,RELATED -j ACCEPT

      # Enable the traffic between the nodes of the cluster
      -A Firewall-INPUT -s $MACHINES_IP -j ACCEPT

      # Allow connections from docker container
      -A Firewall-INPUT -i docker0 -j ACCEPT

      # Accept ssh, http, https and git
      -A Firewall-INPUT -m conntrack --ctstate NEW -m multiport -p tcp --dports 22,80,443 -j ACCEPT

      # Log and drop everything else
      -A Firewall-INPUT -j LOG
      -A Firewall-INPUT -j REJECT

      COMMIT
      EOF
      )

      if [[ -z "$DEBUG" ]]; then
        echo "$template"
      fi

      echo "Saving firewall Rules"
      echo "$template" | sudo tee /var/lib/iptables/rules-save > /dev/null

      echo "Enabling iptables service "
      sudo systemctl enable iptables-restore.service

      # Flush custom rules before the restore (so this script is idempotent)
      # sudo /usr/sbin/iptables -F Firewall-INPUT 2> /dev/null

      #echo "Loading custom iptables firewall"
      #sudo /sbin/iptables-restore --noflush /var/lib/iptables/rules-save

      echo "Done"




